
## 线程安全性

定义：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的、

注意：无状态对象一定是线程安全的

## 原子性

1. 竞态条件： 由于不恰当的执行时序而出现不正确的执行结果

2. 最常见的竞态条件就是"先检查后执行"，即延迟初始化。竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。

3. 复合操作： 将延迟初始化 与 递增操作 统称为 符合操作。应尽可能的利用线程安全对象(如AcomicLong)来管理类的状态。

## 加锁机制

在线程安全性的d定义中要求，多个线程之间的操作无论采用何种执行时序h或交替方式，都要保证不变性条件不被破坏。
要 保持状态的一致性，就需要在单个原子性操作中，更新所有相关的状态变量、

### 内置锁

1. 同步代码块包含两部分：一个座位锁的对象引用，一个作为由这个锁保护的代码块。

2. 每个Java对象都可以用作一个实现同步的锁(内置锁或监视器锁)，进入代码块之前获得锁，执行完后释放锁，
3. 获取内置锁的唯一方法就是进入由这个锁保护的同步代码块或方法、
4. 内置锁保护的同步代码块 会以 原子方式执行

### 重入

如果某个线程试图获得一个已经由他自己获得的锁，那么这个请求就会成功。重入意味着获取锁的操作粒度是线程，而不是调用。

重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。

## 用锁来保护状态

锁能使其保护的代码路径以串行形式来访问。需要通过锁来构造一些协议实现对共享状态的独占访问。

1. 可能被多个线程同时访问的可变状态变量,访问时都需要持有同一个锁。
2. 每个共享的和可变的b变量都应该只由一个锁来保护。
3. 对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。


## 活跃性与性能

1. 应该尽量将 不影响共享状态且执行时间较长的操作 从同步代码块中 分离出去。

2. 通常在简单性与性能之间存在着相互制约因素，当实现某个同步策略时，一定不要为了性能而牺牲简单性(可能会破坏安全性)

3. 执行时间较长的计算，或无法快速完成的操作，一定不要持有锁。

