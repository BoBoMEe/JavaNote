## 概述
算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，每条指令表示一个或多个操作。

## 算法特性
- 输入：零个或者多个输入
- 输出：至少有一个或多个输出
- 有穷性：执行有限步骤后会自动结束（不会出现死循环）
- 确定性：每一步骤都具有确定的含义 
- 可行性： 每一步都必须可行

## 算法设计要求

- 正确性：至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
- 可读性： 便于阅读，理解和交流
- 健壮性：当输入数据不合法时，算法也能做出相关处理
- 时间效率高和存储量低

## 效率的度量方法

### 事后统计法
通过设计好的测试程序和数据进行对比

这种方法需要事先编好程序，有很多缺陷，因此不予考虑。

### 事前分析估算法
在程序编制前，依赖统计方法对算法进行估算，时间消耗取决于以下因素：

- 算法的策略、方法
- 编译产生的代码质量
- 问题的输入规模
- 器指令执行速度

## 函数的渐进式增长

给定两个函数 f（n）和 g（n） ，如果存在一个整数 N，使得对于所有的 n > N， f（n）总是比 g（n）大，那么，我们说 f（n）的增长渐近快于 g（ n）

通过对比发现，算法的执行速度：

- 与最高次想相乘的常数不重要
- 函数随着n的增长，结果也会变得增长特别快
- 判断一个算法的效率时，常数与其他次要项常常可忽略。

## 算法的时间复杂度

### 时间复杂度定义
在进行算法分析时，语句总的执行次数 T（n）是关于问题规模 n
的函数，进而分析 T（n）随 n 的变化情况并确定 T（n）的数量级
。算法的时间复杂度，也就是算法的时间量度，记作： T（n）= O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f（n）是问题规模 n 的某个函数。

> O()：大O记法
> 随n增长T(n)增长最慢的算法是最优算法
> O(1)：常数阶，O(n)：线性阶,O(n2)：平方阶

### 大O推导
1.用常数 1 取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是 1，则去除与这个项相乘的常数

>  常数阶 、线性阶、对数阶、平方阶

## 常见时间复杂度

> O(1) <O(logn)< O(<n)<O(nlogn)< O(n2) <O( n3 ) <O(2^n)<O(n!)<O( n^n )

## 算法的空间复杂度

空间换时间是软件开发常用的手段。

空间复杂度 要通过计算算法所需要的存储空间实现。公式： S(n) = O(f(n));
n为问题规模，f(n)为语句关于n所占存储空间的函数。
