## 概述
算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，每条指令表示一个或多个操作。

## 小栗子，算法比较

计算 1+2+...+100，循环求解法 | 高斯求解法。

## 算法特性
- 输入输出：具有零个或者多个输入，至少有一个或多个输出
- 有穷性：执行有限步骤后会自动结束（不会出现死循环）
- 确定性：每一步骤都具有确定的含义，不会出现二义性
- 可行性： 每一步都必须可行，每一步都能够通过执行有限次数完成

## 算法设计要求

- 正确性：至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
- 可读性： 便于阅读，理解和交流
- 健壮性：当输入数据不合法时，算法也能做出相关处理
- 时间效率高和存储量低：设计算法应该尽量满足此项

## 效率的度量方法

### 事后统计法
通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的运行时间进行对比，从而确定效率高低

这种方法需要事先编好程序，有很多缺陷，因此不予考虑。

### 事前分析估算法
在程序编制前，依赖统计方法对算法进行估算

时间消耗取决于以下因素：

- 算法的策略、方法
- 编译产生的代码质量
- 问题的输入规模
- 器指令执行速度

在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或者一系列步骤。

## 函数的渐进式增长

给定两个函数 `f（n）和 g（n）` ，如果存在一个整数 `N`，使得对于所有的 `n > N`， `f（n）`总是比` g（n）`大，那么，我们说 `f（n）`的增长渐近快于 `g（ n）`

通过对比发现，算法的执行速度：

- 可以忽略加法常数
- 与最高次项相乘的常数不重要
- 最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快
- 判断一个算法的效率时，常数与其他次要项常常可忽略。

需要关注的是 `主项（最高阶项）`的阶数。

## 算法的时间复杂度

### 时间复杂度定义
在进行算法分析时，语句总的执行次数 `T（n）`是关于问题规模` n`
的函数，进而分析 `T（n）`随 `n `的变化情况并确定 `T（n）`的数量级。

算法的时间复杂度，也就是算法的时间量度，记作：` T（n）= O(f(n))`。
它表示随问题规模` n `的增大，算法执行时间的增长率和`f（n）`的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。
其中 `f（n）`是问题规模 `n` 的某个函数。

> 用O()来体现算法时间复杂度的记法：大O记法
> 随n增长T(n)增长最慢的算法是最优算法
> O(1)：常数阶，O(n)：线性阶,O(n2)：平方阶

### 大O阶推导
1.用常数 1 取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是 1，则去除与这个项相乘的常数

>  常数阶 O(1)、线性阶O(n)、对数阶O(logn)、平方阶O(n2)

## 常见时间复杂度

> O(1) <O(logn)< O(<n)<O(nlogn)< O(n2) <O( n3 ) <O(2^n)<O(n!)<O( n^n )

## 最坏情况与平均情况

最坏情况，运行时间将不会再坏了，平均情况居多

通常，除非特别指定，我们提到的运行时间，都是最坏情况下的运行时间。

## 算法的空间复杂度

空间复杂度 要通过计算算法所需要的存储空间实现。公式：` S(n) = O(f(n))`;
n为问题规模，f(n)为语句关于n所占存储空间的函数。

空间换时间是软件开发常用的手段。
