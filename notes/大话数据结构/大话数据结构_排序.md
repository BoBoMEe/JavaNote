## 概述

使得一个序列成为按关键字有序的序列的操作。

## 排序稳定性
排序过程中排序前顺序和排序中不变是稳定排序。

## 内排序和外排序
指待排序所有记录是否在内存中操作。

内排序：在排序整个过程中，待排序的所有记录都被放置在内存中（插入、交换、选择和归并）
外排序： 排序记录态度要在内外存之间多次交换。

内排序主要受三个方面影响：

-  时间性能
-  辅助控件
-  算法的复杂性

## 冒泡排序

依次比较相邻的两个数，将小数放在前面，大数放在后面。

```java
public static void sort(int[] data) {  
for (int i = 0; i < data.length - 1; i++) {  
for (int j = 0; j < data.length - 1 - i; j++) {  
if (data[j] > data[j + 1]) {  
swap(data, j, j + 1);  
}  
}  
}  
}
```

### 复杂度分析

- 最好的情况： 本身就是有序的，需要 n-1 次比较
- 最坏的情况： 逆序，需要 n(n-1)/2 次比较
因此，总的时间复杂度为 O(n^2)。

## 简单选择排序

第一个元素依次和后面的所有元素进行比较。第一次结束后，就会有最小值出现在最前面。依次类推。

```java
public static void sort(int[] data) {  
for (int x = 0; x < data.length - 1; x++) {  
for (int y = x + 1; y < data.length; y++) {  
if (data[y] < data[x]) {  
swap(data, x, y);  
}  
}  
}  
}
```

特点： 
- 交换移动数据次数较少。
- 最好、最坏的情况比较次数相同：n(n-1)/2，最好0次，最差n-1次
因此，时间复杂度依旧为O(n^2)。

## 插入排序

将n个元素的数列分为已有序和无序两个部分，
每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。

```java
public static void sort(int[] data) {  
for (int i = 1; i < data.length; i++) {  
for (int j = i; (j > 0) && (data[j] < data[j - 1]); j--) {  
SortTest.swap(data, j, j - 1);  
}  
}  
}
```

## 希尔排序

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成（n除以d1）个组。
所有距离为d1的倍数的记录放在同一个组中。
先在各组内进行直接插入排序；
然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)，
即所有记录放在同一组中进行直接插入排序为止。

```java
/**
* 希尔排序
* @param arrays 需要排序的序列
*/
public static void sort(int[] arrays){
if(arrays == null || arrays.length <= 1){
return;
}
//增量
int incrementNum = arrays.length/2;
while(incrementNum >=1){
for(int i=0;i<arrays.length;i++){
//进行插入排序
for(int j=i;j<arrays.length-incrementNum;j=j+incrementNum){
if(arrays[j]>arrays[j+incrementNum]){
int temple = arrays[j];
arrays[j] = arrays[j+incrementNum];
arrays[j+incrementNum] = temple;
}
}
}
//设置新的增量
incrementNum = incrementNum/2;
}
}
```

## 归并排序

将两个已经排序的序列合并成一个序列的操作。

```java
/**
* 希尔排序
*
* @param arr 数组
*/
private static void shellSort(int[] arr) {
int i, j;
int tmp;
int increment = arr.length;
do {
increment = increment / 3 + 1;
for (i = increment; i < arr.length; i++) {
j = i - increment;
tmp = arr[i];
while (j >= 0 && tmp < arr[j]) {
arr[j + increment] = arr[j];
j -= increment;
}
arr[j + increment] = tmp;
}
} while (increment > 1);
}
``

## 堆排序

堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。

```java
public class HeapSort {
/**
* 构建大顶堆
*/
public static void adjustHeap(int[] a, int i, int len) {
int temp, j;
temp = a[i];
for (j = 2 * i; j < len; j *= 2) {// 沿关键字较大的孩子结点向下筛选
if (j < len && a[j] < a[j + 1])
++j; // j为关键字中较大记录的下标
if (temp >= a[j])
break;
a[i] = a[j];
i = j;
}
a[i] = temp;
}
public static void heapSort(int[] a) {
int i;
for (i = a.length / 2 - 1; i >= 0; i--) {// 构建一个大顶堆
adjustHeap(a, i, a.length - 1);
}
for (i = a.length - 1; i >= 0; i--) {// 将堆顶记录和当前未经排序子序列的最后一个记录交换
int temp = a[0];
a[0] = a[i];
a[i] = temp;
adjustHeap(a, 0, i - 1);// 将a中前i-1个记录重新调整为大顶堆
}
}
public static void main(String[] args) {
int a[] = { 51, 46, 20, 18, 65, 97, 82, 30, 77, 50 };
heapSort(a);
System.out.println(Arrays.toString(a));
}
} 
```

## 快速排序

1）设置两个变量i、j，排序开始的时候：i=0，j=N-1
2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]、
3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j--），找到第一个小于key的值A[j]，A[i]与A[j]交换
4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++），找到第一个大于key的A[i]，A[i]与A[j]交换； 　　
5）重复第3、4、5步，直到 I=J，(3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。

```java
public class QuickSort {  
public static void sort(int[] data) {  
quickSort(data, 0, data.length - 1);  
}  
private static void quickSort(int[] data, int i, int j) {  
int pivotIndex = (i + j) / 2;  
// swap  
SortTest.swap(data, pivotIndex, j);  

int k = partition(data, i - 1, j, data[j]);  
SortTest.swap(data, k, j);  
if ((k - i) > 1)  
quickSort(data, i, k - 1);  
if ((j - k) > 1)  
quickSort(data, k + 1, j);  
}  
private static int partition(int[] data, int l, int r, int pivot) {  
do {  
while (data[++l] < pivot) ;  
while ((r != 0) && data[--r] > pivot) ;  
SortTest.swap(data, l, r);  
} while (l < r);  
SortTest.swap(data, l, r);  
return l;  
}  
}
```
