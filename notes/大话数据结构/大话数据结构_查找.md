## 概念

根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录

-  查找表： 同一类型数据元素构成的集合
-  查关键字：数据元素中某个数据项的值，用它可以标识一个数据元素
-  静态查找表： 查询某个“特定”数据元素是否存在
-  动态查找表： A)查找时插入数据元素，B)查找时删除数据元素。

## 顺序表查询

又叫线性查找，是最基本的查找技术，从头到尾逐个比较查找。（时间复杂度O(N)）

## 有序表查找

用有序表查找方法时，前提条件是待查找的记录必须是已经排好序的。

### 折半查找（二分查找）

是最经典的有序表查找，要求线性表有序和采用顺序存储

```java
public static int binarySearch(int a[],int goal){  
int high=a.length-1;  
int low=0;  
while (low<=high) {  
int middle=(low+high)/2;  
if (a[middle]==goal) {  
return middle;  
}  else if (a[middle]>goal) {  
high=middle-1;  
}  else {  
low=middle+1;  
}  
}  
return -1;  
}
```

### 差值查找

二分法查找的改进，适用于关键字分布比较均匀的查找表

```java
/* 
* num：有序表（由小到大排列） key：要查找的关键字 return：还回查找到关键字的下标，没有找到则还回-1 
*/  
private static int Insert_Search(int[] num, int key) {  
int low, high, mid;  
low = 0;  
high = num.length - 1;  
while (low <= high) {  
// mid = (low + high) / 2;//二分查找  
mid = low + (high - low) * (key - num[low])/ (num[high] - num[low]); // 插值查找  
if (key < num[mid])  
high = mid - 1;  
else if (key > num[mid])  
low = mid + 1;  
else  
// 如果等于则直接还回下标值  
return mid;  
}  
return -1;  
} 
```

###  斐波那契查找

斐波那契数列，又称黄金分割数列。斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。

```java
public static int fibonacciSearch(int[] data, int key) {  
int low = 0;  
int high = data.length - 1;  
int mid = 0;  

// 斐波那契分割数值下标  
int k = 0;  

// 序列元素个数  
int i = 0;  

// 获取斐波那契数列  
int[] f = fibonacci();  

// 获取斐波那契分割数值下标  
while (data.length > f[k] - 1) {  
k++;  
}  

// 创建临时数组  
int[] temp = new int[f[k] - 1];  
for (int j = 0; j < data.lengt敏感词emp[j] = data[j];  
}  

// 序列补充至f[k]个元素  
// 补充的元素值为最后一个元素的值  
for (i = data.length; i < f[k] - 1; i++) {  
temp[i] = temp[high];  
}  

for (int j : temp) {  
System.out.print(j + " ");  
}  
System.out.println();  

while (low <= high) {  
// low：起始位置  
// 前半部分有f[k-1]个元素，由于下标从0开始  
// 则-1 获取 黄金分割位置元素的下标  
mid = low + f[k - 1] - 1;  

if (temp[mid] > key) {  
// 查找前半部分，高位指针移动  
high = mid - 1;  
// （全部元素） = （前半部分）+（后半部分）  
// f[k] = f[k-1] + f[k-1]  
// 因为前半部分有f[k-1]个元素，所以 k = k-1  
k = k - 1;  
} else if (temp[mid] < key) {  
// 查找后半部分，高位指针移动  
low = mid + 1;  
// （全部元素） = （前半部分）+（后半部分）  
// f[k] = f[k-1] + f[k-1]  
// 因为后半部分有f[k-1]个元素，所以 k = k-2  
k = k - 2;  
} else {  
// 如果为真则找到相应的位置  
if (mid <= high) {  
return mid;  
} else {  
// 出现这种情况是查找到补充的元素  
// 而补充的元素与high位置的元素一样  
return high;  
}  
}  
}  
return -1;  
}  
} 
```

## 线性索引查找

索引是对于按先后顺序存储的海量数据，为了加快查找速度而设计的一种查找结构.

索引：把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项组成。

按结构分类：线性索引，树形索引，多级索引。

线性索引又分为：稠密索引，分块索引，倒排索引。

### 稠密索引

是指在线性索引中，数据集中的每个记录对应一个索引项

特点：记录无序，索引表中的索引项（按关键字）有序，索引项包含2个数据项：a.关键字，b.指针
缺点：索引项个数与数据集中的记录个数相同，空间代价大。

### 分块索引

把数据集的记录按分块有序的原则分成若干块，每一块对应一个索引项

特点：分块有序：
> a.块内无序，块内记录可以无序，
> b.块间有序，块与块之间按关键字有序。

- 索引项包含3个数据项：a.最大关键字，b.快中的记录个数，c.指向块首数据元素的指针。

### 倒排索引

根据属性（字段、次关键码）的值来查找记录，不是由记录确定属性值，而是由属性值确定记录的位置

优点：查找记录非常快。
缺点：记录表号不定长，维护（插入删除等）比较困难。

## 二叉排序树

又称二叉查找树.
顺序线性表的查找快速( 可以用折半，差值，斐波那契)，但是 插入和删除比较慢、二叉排序树就是为了解决这个问题的。

二叉排序树的插入操作：先查找遍历树确定没有该元素在插入。
删除元素不用遍历整个树找到即可删除，如果删除节点有子树，其直接前驱或者后继将作为新的连接点。

## 平衡二叉树（AVL树）

是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1.
这是为了解决 树太高 会导致 查找效率变低

## 多路查找树 （B树）

每一个节点的孩子数可以多余两个，且每一个节点处可以存储多个元素。由于它是查找树，所有的元素之间存在某种特定的排序关系。
包含了四种形式：

-  2-3树： 2结点或3结点
-  2-3-4树： 2结点或3结点或4结点
-  B树：平衡的多路查找树
-  B+树： 应文件系统所需而出现的一种B树的变形，解决了所有元素遍历等基本问题

## 散列查找

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。用散列技术将记录存储在一块连续的存储空间中，该存储空间称为散列表。

特点： 不用比较，直接通过关键字key得到要查找记录的存储位置。
散列技术既是一种存储方法，也是一种查找方法。

散列函数的构造方法需要遵循以下原则：

> a.计算简单，
> b.散列地址分布均匀


## 散列冲突

处理散列冲突的方法有以下几种：

- 开放定址探测法
- 再散列函数法
- 链地址法
- 公共溢出区法
